from typing import Annotated, Any

from mcp.server.fastmcp import FastMCP

_mcp = FastMCP("WorkflowAI ðŸš€", stateless_http=True)


@_mcp.tool()
async def list_available_models() -> dict[str, Any]:
    """<when_to_use>
    When you need to pick a model for the user's WorkflowAI agent, or any model-related goal.
    </when_to_use>
    <returns>
    Returns a list of all available AI models from WorkflowAI.
    </returns>"""
    # TODO: Implement with proper authentication
    return {"error": "Authentication not yet implemented with official MCP SDK", "models": []}


@_mcp.tool()
async def list_agents(
    from_date: Annotated[
        str,
        "ISO date string to filter stats from (e.g., '2024-01-01T00:00:00Z'). Defaults to 7 days ago if not provided.",
    ],
) -> dict[str, Any]:
    """<when_to_use>
    When the user wants to see all agents they have created, along with their statistics (run counts and costs on the last 7 days).
    </when_to_use>
    <returns>
    Returns a list of all agents for the user along with their statistics (run counts and costs).
    </returns>"""
    # TODO: Implement with proper authentication
    return {"error": "Authentication not yet implemented with official MCP SDK", "agents": []}


@_mcp.tool()
async def fetch_run_details(
    agent_id: Annotated[
        str | None,
        "The id of the user's agent, example: 'email-filtering-agent'. Pass 'new' when the user wants to create a new agent.",
    ] = None,
    run_id: Annotated[
        str | None,
        "The id of the run to fetch details for",
    ] = None,
    run_url: Annotated[
        str | None,
        "The url of the run to fetch details for",
    ] = None,
) -> dict[str, Any]:
    """<when_to_use>
    When the user wants to investigate a specific run of a WorkflowAI agent, for debugging, improving the agent, fixing a problem on a specific use case, or any other reason. This is particularly useful for:
    - Debugging failed runs by examining error details and input/output data
    - Analyzing successful runs to understand agent behavior and performance
    - Reviewing cost and duration metrics for optimization
    - Examining user and AI reviews for quality assessment
    - Troubleshooting specific use cases by examining exact inputs and outputs

    You must either pass run_id + agent_id OR run_url. The run_url approach is convenient when you have a direct link to the run from the WorkflowAI dashboard.
    </when_to_use>
    <returns>
    Returns comprehensive details of a specific WorkflowAI agent run, including:

    **Core Run Information:**
    - id: Unique identifier for this specific run
    - agent_id: The ID of the agent that was executed
    - agent_schema_id: The schema/version ID of the agent used for this run
    - status: Current status of the run (e.g., "completed", "failed", "running")
    - conversation_id: Links this run to a broader conversation context if applicable

    **Input/Output Data:**
    - agent_input: Complete input data provided to the agent for this run
    - agent_output: Complete output/response generated by the agent

    **Performance Metrics:**
    - duration_seconds: Execution time in seconds
    - cost_usd: Cost of this run in USD (based on model usage, tokens, etc.)
    - created_at: ISO timestamp of when the run was created/started

    **Quality Assessment:**
    - user_review: Any review or feedback provided by the user for this run
    - ai_review: Automated review or assessment generated by the AI system

    **Error Information:**
    - error: If the run failed, contains error code, message, and detailed information for debugging

    This data structure provides everything needed for debugging, performance analysis, cost tracking, and understanding the complete execution context of your WorkflowAI agent.
    </returns>"""
    # TODO: Implement with proper authentication
    return {"error": "Authentication not yet implemented with official MCP SDK", "run": None}


@_mcp.tool()
async def get_agent_versions(
    task_id: Annotated[str, "The task ID of the agent"],
    version_id: Annotated[
        str | None,
        "An optional version id, e-g 1.1. If not provided all versions are returned",
    ] = None,
) -> dict[str, Any]:
    """<when_to_use>
    When the user wants to retrieve details of versions of a WorkflowAI agent, or when they want to compare a specific version of an agent.
    </when_to_use>
    <returns>
    Returns the details of one or more versions of a WorkflowAI agent.
    </returns>"""
    # TODO: Implement with proper authentication
    return {"error": "Authentication not yet implemented with official MCP SDK", "versions": []}


@_mcp.tool()
async def ask_ai_engineer(
    agent_id: Annotated[
        str,
        "The id of the user's agent, MUST be passed when the user is asking a question in the context of a specific agent. Example: 'email-filtering-agent' in 'model=email-filtering-agent/gpt-4o-latest'. Pass 'new' when the user wants to create a new agent.",
    ],
    message: Annotated[
        str,
        "Your message to the AI engineer about what help you need",
    ] = "I need help improving my agent",
    agent_schema_id: Annotated[
        int | None,
        "The schema ID of the user's agent version, if known from model=<agent_id>/<agent_schema_id>/<deployment_environment> when the workflowAI agent is already deployed",
    ] = None,
    user_programming_language: Annotated[
        str | None,
        "The programming language and integration (if known) used by the user, e.g, Typescript, Python with OpenAI SDK, etc.",
    ] = None,
    user_code_extract: Annotated[
        str | None,
        "The code you are working on to improve the user's agent, if any. Please DO NOT include API keys or other sensitive information.",
    ] = None,
) -> dict[str, Any]:
    """
    <when_to_use>
    Most user request about WorkflowAI must be processed by starting a conversation with the AI engineer agent to get insight about the WorkflowAI platform and the user's agents.
    </when_to_use>

    <returns>
    Returns a response from WorkflowAI's AI engineer (meta agent) to help improve your agent.
    </returns>
    Get a response from WorkflowAI's AI engineer (meta agent) to help improve your agent.
    """
    # TODO: Implement with proper authentication
    return {"error": "Authentication not yet implemented with official MCP SDK", "response": ""}


@_mcp.tool()
async def deploy_agent_version(
    agent_id: Annotated[str, "The id of the agent to deploy, e.g., 'email-filtering-agent'"],
    version_id: Annotated[
        str,
        "The version ID to deploy (e.g., '1.0', '2.1', or a hash). This can be obtained from the agent versions list or from the version_id metadata in chat completion responses.",
    ],
    environment: Annotated[
        str,
        "The deployment environment. Must be one of: 'dev', 'staging', or 'production'",
    ],
) -> dict[str, Any]:
    """<when_to_use>
    When the user wants to deploy a specific version of their WorkflowAI agent to an environment (dev, staging, or production).

    The version ID can be obtained by:
    1. Asking the user which version they want to deploy
    2. Using the get_agent_versions tool to list available versions
    3. Checking the response payload from a chat completion endpoint which contains version_id metadata
    </when_to_use>

    <returns>
    Returns deployment confirmation with:
    - version_id: The deployed version ID
    - task_schema_id: The schema ID of the deployed version
    - environment: The deployment environment
    - deployed_at: The deployment timestamp
    - message: Success message
    - migration_guide: Detailed instructions on how to update your code to use the deployed version, including:
      - model_parameter: The exact model parameter to use in your code
      - migration_instructions: Step-by-step examples for both scenarios (with and without input variables)
      - important_notes: Key considerations for the migration
    </returns>"""
    # TODO: Implement with proper authentication
    return {"error": "Authentication not yet implemented with official MCP SDK", "deployment": None}


def mcp_http_app():
    return _mcp.http_app(path="/sse")
